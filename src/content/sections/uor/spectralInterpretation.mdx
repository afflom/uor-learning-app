import React from 'react'
import SubsectionTemplate from '../../../templates/SubsectionTemplate'
import { spectralInterpretation } from '../metadata'

/**
 * Subsection: Spectral Interpretation
 * Viewing prime decomposition as a frequency spectrum.
 */
function SpectralInterpretationSubsection() {
  return (
    <SubsectionTemplate metadata={spectralInterpretation}>
      <p>
        <strong>Definition (Prime Spectrum):</strong> For x âˆˆ ğ’°^Ã— with prime-
        valuation vector Ï†(x) = (a_p)_{pâˆˆP}, we define the <em>prime spectrum</em>
        Ïƒ_x: P â†’ â„¤ by Ïƒ_x(p) = a_p. The support supp(Ïƒ_x) is finite, and
        Ïƒ_x is a discrete spectral measure on the primes.
      </p>
      <p>
        In this analogy, each prime p plays the role of a fundamental frequency
        and a_p the intensity (amplitude) at that frequency. The function Ïƒ_x
        is the exact spectral decomposition of x, with no continuous component
        and no information loss.
      </p>
      <p>
        Because Ï† is injective, no two distinct objects share the same prime-
        frequency spectrum, making this analogy a perfect fingerprinting
        mechanism. This spectral view invites techniques from signal
        processingâ€”filtering, convolution, harmonic analysisâ€”to enrich number
        theory and beyond.
      </p>
      <h4>Analogue Dictionary</h4>
      <ul>
        <li>
          <strong>Domain Element â†” Signal:</strong> x â†¦ Ïƒ_x is a bijection
          between ğ’°^Ã— and its frequency spectra.
        </li>
        <li>
          <strong>Multiplication â†” Spectral Superposition:</strong>
          Ïƒ_{xâˆ˜y}=Ïƒ_x + Ïƒ_y, analogous to additive combination of spectra
          under convolution in time domain.
        </li>
        <li>
          <strong>Exponentiation â†” Frequency Scaling:</strong>
          Ïƒ_{x^n}=nÂ·Ïƒ_x multiplies amplitudes, akin to harmonic reinforcement.
        </li>
        <li>
          <strong>GCD/LCM â†” Spectral Filtering:</strong>
          Ïƒ_{gcd(x,y)} = min(Ïƒ_x,Ïƒ_y), Ïƒ_{lcm(x,y)} = max(Ïƒ_x,Ïƒ_y).
        </li>
        <li>
          <strong>Zero Padding Analogue:</strong> Embedding x in a larger UFD
          adds zero-amplitude frequencies at new primes.
        </li>
      </ul>
      <ul>
        <li>
          <strong>Signal â†’ Object:</strong> The factorization spectrum
          <code>{`{(p,a_p)}`}</code> fully characterizes the object, just as
          Fourier coefficients characterize a signal.
        </li>
        <li>
          <strong>Convolution â†’ Multiplication:</strong> Combining objects
          multiplies them and adds their spectra:
          <code>Ï†(XÂ·Y)=Ï†(X)+Ï†(Y)</code>.
        </li>
        <li>
          <strong>Harmonics:</strong> Repeated factors <code>pÂ², pÂ³, â€¦</code>
          act like higher harmonics, increasing amplitude at frequency{' '}
          <code>p</code>.
        </li>
        <li>
          <strong>Filtering:</strong> Operations like gcd and lcm correspond to
          componentwise min/max on the spectrum (filtering frequencies).
        </li>
      </ul>
      <p>
        <strong>Spectral Theorem (Discrete Prime Domain):</strong> The map
        Ïƒ: ğ’°^Ã— â†’ â„¤^{(P)} is a spectral transform that diagonalizes the monoid
        action: any multiplicative operation on x,y corresponds to additive
        operations on Ïƒ(x),Ïƒ(y). This is the analogue of Fourier diagonalization
        for the multiplicative monoid.
      </p>
      <p>
        Beyond analogy, one can define <em>spectral operators</em> in prime space:
        linear functionals f: â„¤^{(P)} â†’ R capturing arithmetic invariants,
        spectral convolutions modeling distribution of primes, and even
        zeta-like transforms Î¶(s) = âˆ‘_{p} a_p p^{-s} as generating functions.
        This confluence of number theory and harmonic analysis exemplifies the
        unifying power of the Prime Framework.
      </p>
    </SubsectionTemplate>
  )
}

export default SpectralInterpretationSubsection
